<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".h" #>
<#@ include file="Parameters.ttinclude" #><#@ include file="Implementation.ttinclude" #><#
    this.processParameters();
#><#@ include file="Copyright.ttinclude" #>
#ifndef <#= guardName #>_H_INCLUDED
#define <#= guardName #>_H_INCLUDED
#if (defined(_MSC_VER) && (_MSC_VER > 1000))
#pragma once
#endif /* (defined(_MSC_VER) && (_MSC_VER > 1000)) */
#if defined(_WIN32) && defined(_MANAGED)
#pragma managed(push, off)
#endif /* defined(_WIN32) && defined(_MANAGED) */

#include "the/config.h"

<#
    List<string> includes = new List<string>(baseClasses);
    if (!string.IsNullOrWhiteSpace(this.templateDecl)) {
        includes.Add("the::not_implemented_exception");
        includes.Add("the::stack_trace");
    }
    includes.Sort();
    foreach (string i in includes) {
        WriteLine("#include \"" + i.Replace(NAMESPACE_DELIM[0],
            Path.AltDirectorySeparatorChar.ToString()) + ".h\"");
    }
#>


<#
    for (int i = 0; i < nameList.Length - 1; ++i) {
        WriteLine("namespace " + nameList[i] + " {");
    }
#>

    /**
     * TODO: Document '<#= className #>'.
     */
    <# if (!string.IsNullOrWhiteSpace(this.templateDecl)) {
        this.Write(this.templateDecl + " ");
    }
#>class <#= className #><# 
    if (baseClasses.Count > 0) { 
        Write(" : public ");
        Write(string.Join(", public ", baseClasses));
    }
#> {

    public:

        /**
         * Initialises a new instance.
         */
        <#= className #>(void);

<# 
    if (makeCopyable) { 
#>
        /**
         * Create a clone of 'rhs'.
         *
         * @param rhs The object to be cloned.
         */
        <#= className #>(const <#= className #>& rhs);

<#
     } 
#>
        /** Dtor. */
        <# if (makeDtorVirtual) { Write("virtual "); } #>~<#= className #>(void);

<# 
    if (makeCopyable) { 
#>
        /**
         * Assign values of 'rhs' to this object.
         *
         * @param rhs The right hand side operand.
         *
         * @return *this.
         */
        <#= className #>& operator =(const <#= className #>& rhs);

<# 
    } 
#>
<# 
    if (baseClasses.Count == 1) { 
#>
    protected:

        /** Super class typedef. */
        typedef <#= baseClasses.First() #> base;

<# 
    } 
#>
    };

<#
    for (int i = nameList.Length - 2; i >= 0; --i) {
        WriteLine("} /* end namespace " + nameList[i] + " */");
    }
#>

<#
    if (!string.IsNullOrWhiteSpace(this.templateDecl)) {
        this.WriteLine(string.Empty);
        this.renderImplementation();
        this.WriteLine(string.Empty);
    }
#>
#if defined(_WIN32) && defined(_MANAGED)
#pragma managed(pop)
#endif /* defined(_WIN32) && defined(_MANAGED) */
#endif /* <#= guardName #>_H_INCLUDED */
