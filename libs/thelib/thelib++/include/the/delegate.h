/*
 * the/delegate.h
 *
 * Copyright (c) 2012-2013, TheLib Team (http://www.thelib.org/license)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * - Neither the name of TheLib, TheLib Team, nor the names of its
 *   contributors may be used to endorse or promote products derived from this
 *   software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THELIB TEAM AS IS AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL THELIB TEAM BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Delegate.h
 *
 * Copyright (C) 2006 - 2011 by Visualisierungsinstitut Universitaet Stuttgart. 
 * Alle Rechte vorbehalten.
 */

#ifndef THE_DELEGATE_H_INCLUDED
#define THE_DELEGATE_H_INCLUDED
#if (defined(_MSC_VER) && (_MSC_VER > 1000))
#pragma once
#endif /* (defined(_MSC_VER) && (_MSC_VER > 1000)) */
#if defined(_WIN32) && defined(_MANAGED)
#pragma managed(push, off)
#endif /* defined(_WIN32) && defined(_MANAGED) */

#include "the/assert.h"
#include "the/invalid_operation_exception.h"
#include "the/memory.h"
#include "the/stack_trace.h"
#include <memory.h>


/*
 * This file is generated by 'generateDelegate.pl'
 */


namespace the {


    /**
     * Class representing a single callback target, which can either be a
     * function (c or static member) or a member-object pair, both with an
     * optional context object (usually a pointer).
     *
     * The first template parameter specifies the return value.
     * The other template parameters define the parameter list of the
     * callback, while void is used to (implicitly) terminate the list.
     * The parameter list may only have a maximum of 10 elements.
     */
    template<class Rv = void, class P1 = void, class P2 = void, class P3 = void, class P4 = void, class P5 = void, class P6 = void, class P7 = void, class P8 = void, class P9 = void, class P10 = void>
    class delegate {
    public:

        /** type for the return value */
        typedef Rv return_value_type;

        /** type for the 1th parameter */
        typedef P1 param1_type;

        /** type for the 2th parameter */
        typedef P2 param2_type;

        /** type for the 3th parameter */
        typedef P3 param3_type;

        /** type for the 4th parameter */
        typedef P4 param4_type;

        /** type for the 5th parameter */
        typedef P5 param5_type;

        /** type for the 6th parameter */
        typedef P6 param6_type;

        /** type for the 7th parameter */
        typedef P7 param7_type;

        /** type for the 8th parameter */
        typedef P8 param8_type;

        /** type for the 9th parameter */
        typedef P9 param9_type;

        /** type for the 10th parameter */
        typedef P10 param10_type;

        /**
         * Ctor
         */
        delegate(void) : callee(nullptr) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        delegate(const delegate& src) : callee(nullptr) {
            THE_STACK_TRACE;
            (*this) = src;
        }

        /**
         * Move ctor
         *
         * @param src The object to move from
         */
        delegate(delegate&& src) : callee(nullptr) {
            THE_STACK_TRACE;
            this->callee.swap(src.callee);
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10))
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_callee(funcPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, CT1), CT2 ctxt)
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_context_callee<CT1>(funcPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10))
                : callee(new method_callee<C>(obj, methPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, CT1), CT2 ctxt)
                : callee(new method_context_callee<C, CT1>(obj, methPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~delegate(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool is_target_set(void) const {
            THE_STACK_TRACE;
            return (this->callee != nullptr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param src The source delegate object
         */
        void set(const delegate& src) {
            THE_STACK_TRACE;
            this->callee = src.callee;
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void unset(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        Rv operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) {
            THE_STACK_TRACE;
            std::shared_ptr<abstract_callee> c = this->callee;
            if (!c) {
                throw the::invalid_operation_exception("Delegate target not set", __FILE__, __LINE__);
            }
            return c->call(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const delegate& rhs) const {
            THE_STACK_TRACE;
            if (!this->callee) {
                return !rhs.callee;
            }
            return this->callee->equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(const delegate& rhs) {
            THE_STACK_TRACE;
            this->callee = rhs.callee;
            return *this;
        }

        /**
         * Move operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(delegate&& rhs) {
            THE_STACK_TRACE;
            this->callee.swap(rhs.callee);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class abstract_callee {
        public:

            /** Ctor */
            abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Dtor */
            virtual ~abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class function_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            function_callee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10)) : abstract_callee(), func(func) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) {
                THE_STACK_TRACE;
                return this->func(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_callee *r= dynamic_cast<const function_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class function_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            function_context_callee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, CT1), CT1 ctxt) : abstract_callee(), func(func), ctxt(ctxt) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_context_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) {
                THE_STACK_TRACE;
                return this->func(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_context_callee *r= dynamic_cast<const function_context_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class method_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_callee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10)) : abstract_callee(), obj(obj), meth(meth) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) {
                THE_STACK_TRACE;
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_callee *r= dynamic_cast<const method_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class method_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_context_callee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, CT1), CT1 ctxt) : abstract_callee(), obj(obj), meth(meth), ctxt(ctxt) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_context_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10) {
                THE_STACK_TRACE;
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_context_callee *r= dynamic_cast<const method_context_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        std::shared_ptr<abstract_callee> callee;

    };


    /**
     * Template specialication for delegate functions with 9 parameters
     */
    template<class Rv, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class P8, class P9>
    class delegate<Rv, P1, P2, P3, P4, P5, P6, P7, P8, P9, void> {
    public:

        /** type for the return value */
        typedef Rv return_value_type;

        /** type for the 1th parameter */
        typedef P1 param1_type;

        /** type for the 2th parameter */
        typedef P2 param2_type;

        /** type for the 3th parameter */
        typedef P3 param3_type;

        /** type for the 4th parameter */
        typedef P4 param4_type;

        /** type for the 5th parameter */
        typedef P5 param5_type;

        /** type for the 6th parameter */
        typedef P6 param6_type;

        /** type for the 7th parameter */
        typedef P7 param7_type;

        /** type for the 8th parameter */
        typedef P8 param8_type;

        /** type for the 9th parameter */
        typedef P9 param9_type;

        /** type for the 10th parameter */
        typedef void param10_type;

        /**
         * Ctor
         */
        delegate(void) : callee(nullptr) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        delegate(const delegate& src) : callee(nullptr) {
            THE_STACK_TRACE;
            (*this) = src;
        }

        /**
         * Move ctor
         *
         * @param src The object to move from
         */
        delegate(delegate&& src) : callee(nullptr) {
            THE_STACK_TRACE;
            this->callee.swap(src.callee);
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9))
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_callee(funcPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, CT1), CT2 ctxt)
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_context_callee<CT1>(funcPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9))
                : callee(new method_callee<C>(obj, methPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, P9, CT1), CT2 ctxt)
                : callee(new method_context_callee<C, CT1>(obj, methPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~delegate(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool is_target_set(void) const {
            THE_STACK_TRACE;
            return (this->callee != nullptr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param src The source delegate object
         */
        void set(const delegate& src) {
            THE_STACK_TRACE;
            this->callee = src.callee;
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void unset(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        Rv operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
            THE_STACK_TRACE;
            std::shared_ptr<abstract_callee> c = this->callee;
            if (!c) {
                throw the::invalid_operation_exception("Delegate target not set", __FILE__, __LINE__);
            }
            return c->call(p1, p2, p3, p4, p5, p6, p7, p8, p9);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const delegate& rhs) const {
            THE_STACK_TRACE;
            if (!this->callee) {
                return !rhs.callee;
            }
            return this->callee->equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(const delegate& rhs) {
            THE_STACK_TRACE;
            this->callee = rhs.callee;
            return *this;
        }

        /**
         * Move operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(delegate&& rhs) {
            THE_STACK_TRACE;
            this->callee.swap(rhs.callee);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class abstract_callee {
        public:

            /** Ctor */
            abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Dtor */
            virtual ~abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class function_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            function_callee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9)) : abstract_callee(), func(func) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
                THE_STACK_TRACE;
                return this->func(p1, p2, p3, p4, p5, p6, p7, p8, p9);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_callee *r= dynamic_cast<const function_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class function_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            function_context_callee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9, CT1), CT1 ctxt) : abstract_callee(), func(func), ctxt(ctxt) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_context_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
                THE_STACK_TRACE;
                return this->func(p1, p2, p3, p4, p5, p6, p7, p8, p9, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_context_callee *r= dynamic_cast<const function_context_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, P9, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class method_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_callee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9)) : abstract_callee(), obj(obj), meth(meth) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
                THE_STACK_TRACE;
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7, p8, p9);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_callee *r= dynamic_cast<const method_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class method_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_context_callee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9, CT1), CT1 ctxt) : abstract_callee(), obj(obj), meth(meth), ctxt(ctxt) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_context_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9) {
                THE_STACK_TRACE;
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7, p8, p9, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_context_callee *r= dynamic_cast<const method_context_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, P9, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        std::shared_ptr<abstract_callee> callee;

    };


    /**
     * Template specialication for delegate functions with 8 parameters
     */
    template<class Rv, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class P8>
    class delegate<Rv, P1, P2, P3, P4, P5, P6, P7, P8, void, void> {
    public:

        /** type for the return value */
        typedef Rv return_value_type;

        /** type for the 1th parameter */
        typedef P1 param1_type;

        /** type for the 2th parameter */
        typedef P2 param2_type;

        /** type for the 3th parameter */
        typedef P3 param3_type;

        /** type for the 4th parameter */
        typedef P4 param4_type;

        /** type for the 5th parameter */
        typedef P5 param5_type;

        /** type for the 6th parameter */
        typedef P6 param6_type;

        /** type for the 7th parameter */
        typedef P7 param7_type;

        /** type for the 8th parameter */
        typedef P8 param8_type;

        /** type for the 9th parameter */
        typedef void param9_type;

        /** type for the 10th parameter */
        typedef void param10_type;

        /**
         * Ctor
         */
        delegate(void) : callee(nullptr) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        delegate(const delegate& src) : callee(nullptr) {
            THE_STACK_TRACE;
            (*this) = src;
        }

        /**
         * Move ctor
         *
         * @param src The object to move from
         */
        delegate(delegate&& src) : callee(nullptr) {
            THE_STACK_TRACE;
            this->callee.swap(src.callee);
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8))
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_callee(funcPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, P8, CT1), CT2 ctxt)
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_context_callee<CT1>(funcPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8))
                : callee(new method_callee<C>(obj, methPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, P8, CT1), CT2 ctxt)
                : callee(new method_context_callee<C, CT1>(obj, methPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~delegate(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool is_target_set(void) const {
            THE_STACK_TRACE;
            return (this->callee != nullptr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param src The source delegate object
         */
        void set(const delegate& src) {
            THE_STACK_TRACE;
            this->callee = src.callee;
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void unset(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        Rv operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
            THE_STACK_TRACE;
            std::shared_ptr<abstract_callee> c = this->callee;
            if (!c) {
                throw the::invalid_operation_exception("Delegate target not set", __FILE__, __LINE__);
            }
            return c->call(p1, p2, p3, p4, p5, p6, p7, p8);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const delegate& rhs) const {
            THE_STACK_TRACE;
            if (!this->callee) {
                return !rhs.callee;
            }
            return this->callee->equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(const delegate& rhs) {
            THE_STACK_TRACE;
            this->callee = rhs.callee;
            return *this;
        }

        /**
         * Move operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(delegate&& rhs) {
            THE_STACK_TRACE;
            this->callee.swap(rhs.callee);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class abstract_callee {
        public:

            /** Ctor */
            abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Dtor */
            virtual ~abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class function_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            function_callee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8)) : abstract_callee(), func(func) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
                THE_STACK_TRACE;
                return this->func(p1, p2, p3, p4, p5, p6, p7, p8);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_callee *r= dynamic_cast<const function_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class function_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            function_context_callee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, CT1), CT1 ctxt) : abstract_callee(), func(func), ctxt(ctxt) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_context_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
                THE_STACK_TRACE;
                return this->func(p1, p2, p3, p4, p5, p6, p7, p8, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_context_callee *r= dynamic_cast<const function_context_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5, P6, P7, P8, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class method_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_callee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8)) : abstract_callee(), obj(obj), meth(meth) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
                THE_STACK_TRACE;
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7, p8);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_callee *r= dynamic_cast<const method_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class method_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_context_callee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, CT1), CT1 ctxt) : abstract_callee(), obj(obj), meth(meth), ctxt(ctxt) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_context_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {
                THE_STACK_TRACE;
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7, p8, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_context_callee *r= dynamic_cast<const method_context_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, P8, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        std::shared_ptr<abstract_callee> callee;

    };


    /**
     * Template specialication for delegate functions with 7 parameters
     */
    template<class Rv, class P1, class P2, class P3, class P4, class P5, class P6, class P7>
    class delegate<Rv, P1, P2, P3, P4, P5, P6, P7, void, void, void> {
    public:

        /** type for the return value */
        typedef Rv return_value_type;

        /** type for the 1th parameter */
        typedef P1 param1_type;

        /** type for the 2th parameter */
        typedef P2 param2_type;

        /** type for the 3th parameter */
        typedef P3 param3_type;

        /** type for the 4th parameter */
        typedef P4 param4_type;

        /** type for the 5th parameter */
        typedef P5 param5_type;

        /** type for the 6th parameter */
        typedef P6 param6_type;

        /** type for the 7th parameter */
        typedef P7 param7_type;

        /** type for the 8th parameter */
        typedef void param8_type;

        /** type for the 9th parameter */
        typedef void param9_type;

        /** type for the 10th parameter */
        typedef void param10_type;

        /**
         * Ctor
         */
        delegate(void) : callee(nullptr) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        delegate(const delegate& src) : callee(nullptr) {
            THE_STACK_TRACE;
            (*this) = src;
        }

        /**
         * Move ctor
         *
         * @param src The object to move from
         */
        delegate(delegate&& src) : callee(nullptr) {
            THE_STACK_TRACE;
            this->callee.swap(src.callee);
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7))
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_callee(funcPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, P7, CT1), CT2 ctxt)
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_context_callee<CT1>(funcPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7))
                : callee(new method_callee<C>(obj, methPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, P7, CT1), CT2 ctxt)
                : callee(new method_context_callee<C, CT1>(obj, methPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~delegate(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool is_target_set(void) const {
            THE_STACK_TRACE;
            return (this->callee != nullptr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param src The source delegate object
         */
        void set(const delegate& src) {
            THE_STACK_TRACE;
            this->callee = src.callee;
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void unset(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        Rv operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
            THE_STACK_TRACE;
            std::shared_ptr<abstract_callee> c = this->callee;
            if (!c) {
                throw the::invalid_operation_exception("Delegate target not set", __FILE__, __LINE__);
            }
            return c->call(p1, p2, p3, p4, p5, p6, p7);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const delegate& rhs) const {
            THE_STACK_TRACE;
            if (!this->callee) {
                return !rhs.callee;
            }
            return this->callee->equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(const delegate& rhs) {
            THE_STACK_TRACE;
            this->callee = rhs.callee;
            return *this;
        }

        /**
         * Move operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(delegate&& rhs) {
            THE_STACK_TRACE;
            this->callee.swap(rhs.callee);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class abstract_callee {
        public:

            /** Ctor */
            abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Dtor */
            virtual ~abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class function_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            function_callee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7)) : abstract_callee(), func(func) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
                THE_STACK_TRACE;
                return this->func(p1, p2, p3, p4, p5, p6, p7);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_callee *r= dynamic_cast<const function_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5, P6, P7);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class function_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            function_context_callee(Rv (*func)(P1, P2, P3, P4, P5, P6, P7, CT1), CT1 ctxt) : abstract_callee(), func(func), ctxt(ctxt) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_context_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
                THE_STACK_TRACE;
                return this->func(p1, p2, p3, p4, p5, p6, p7, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_context_callee *r= dynamic_cast<const function_context_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5, P6, P7, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class method_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_callee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7)) : abstract_callee(), obj(obj), meth(meth) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
                THE_STACK_TRACE;
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_callee *r= dynamic_cast<const method_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class method_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_context_callee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, CT1), CT1 ctxt) : abstract_callee(), obj(obj), meth(meth), ctxt(ctxt) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_context_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) {
                THE_STACK_TRACE;
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, p7, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_context_callee *r= dynamic_cast<const method_context_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5, P6, P7, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        std::shared_ptr<abstract_callee> callee;

    };


    /**
     * Template specialication for delegate functions with 6 parameters
     */
    template<class Rv, class P1, class P2, class P3, class P4, class P5, class P6>
    class delegate<Rv, P1, P2, P3, P4, P5, P6, void, void, void, void> {
    public:

        /** type for the return value */
        typedef Rv return_value_type;

        /** type for the 1th parameter */
        typedef P1 param1_type;

        /** type for the 2th parameter */
        typedef P2 param2_type;

        /** type for the 3th parameter */
        typedef P3 param3_type;

        /** type for the 4th parameter */
        typedef P4 param4_type;

        /** type for the 5th parameter */
        typedef P5 param5_type;

        /** type for the 6th parameter */
        typedef P6 param6_type;

        /** type for the 7th parameter */
        typedef void param7_type;

        /** type for the 8th parameter */
        typedef void param8_type;

        /** type for the 9th parameter */
        typedef void param9_type;

        /** type for the 10th parameter */
        typedef void param10_type;

        /**
         * Ctor
         */
        delegate(void) : callee(nullptr) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        delegate(const delegate& src) : callee(nullptr) {
            THE_STACK_TRACE;
            (*this) = src;
        }

        /**
         * Move ctor
         *
         * @param src The object to move from
         */
        delegate(delegate&& src) : callee(nullptr) {
            THE_STACK_TRACE;
            this->callee.swap(src.callee);
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6))
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_callee(funcPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, P6, CT1), CT2 ctxt)
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_context_callee<CT1>(funcPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6))
                : callee(new method_callee<C>(obj, methPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, P6, CT1), CT2 ctxt)
                : callee(new method_context_callee<C, CT1>(obj, methPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~delegate(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool is_target_set(void) const {
            THE_STACK_TRACE;
            return (this->callee != nullptr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param src The source delegate object
         */
        void set(const delegate& src) {
            THE_STACK_TRACE;
            this->callee = src.callee;
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void unset(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        Rv operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
            THE_STACK_TRACE;
            std::shared_ptr<abstract_callee> c = this->callee;
            if (!c) {
                throw the::invalid_operation_exception("Delegate target not set", __FILE__, __LINE__);
            }
            return c->call(p1, p2, p3, p4, p5, p6);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const delegate& rhs) const {
            THE_STACK_TRACE;
            if (!this->callee) {
                return !rhs.callee;
            }
            return this->callee->equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(const delegate& rhs) {
            THE_STACK_TRACE;
            this->callee = rhs.callee;
            return *this;
        }

        /**
         * Move operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(delegate&& rhs) {
            THE_STACK_TRACE;
            this->callee.swap(rhs.callee);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class abstract_callee {
        public:

            /** Ctor */
            abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Dtor */
            virtual ~abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class function_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            function_callee(Rv (*func)(P1, P2, P3, P4, P5, P6)) : abstract_callee(), func(func) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
                THE_STACK_TRACE;
                return this->func(p1, p2, p3, p4, p5, p6);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_callee *r= dynamic_cast<const function_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5, P6);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class function_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            function_context_callee(Rv (*func)(P1, P2, P3, P4, P5, P6, CT1), CT1 ctxt) : abstract_callee(), func(func), ctxt(ctxt) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_context_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
                THE_STACK_TRACE;
                return this->func(p1, p2, p3, p4, p5, p6, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_context_callee *r= dynamic_cast<const function_context_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5, P6, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class method_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_callee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6)) : abstract_callee(), obj(obj), meth(meth) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
                THE_STACK_TRACE;
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_callee *r= dynamic_cast<const method_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5, P6);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class method_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_context_callee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, P6, CT1), CT1 ctxt) : abstract_callee(), obj(obj), meth(meth), ctxt(ctxt) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_context_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) {
                THE_STACK_TRACE;
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5, p6, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_context_callee *r= dynamic_cast<const method_context_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5, P6, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        std::shared_ptr<abstract_callee> callee;

    };


    /**
     * Template specialication for delegate functions with 5 parameters
     */
    template<class Rv, class P1, class P2, class P3, class P4, class P5>
    class delegate<Rv, P1, P2, P3, P4, P5, void, void, void, void, void> {
    public:

        /** type for the return value */
        typedef Rv return_value_type;

        /** type for the 1th parameter */
        typedef P1 param1_type;

        /** type for the 2th parameter */
        typedef P2 param2_type;

        /** type for the 3th parameter */
        typedef P3 param3_type;

        /** type for the 4th parameter */
        typedef P4 param4_type;

        /** type for the 5th parameter */
        typedef P5 param5_type;

        /** type for the 6th parameter */
        typedef void param6_type;

        /** type for the 7th parameter */
        typedef void param7_type;

        /** type for the 8th parameter */
        typedef void param8_type;

        /** type for the 9th parameter */
        typedef void param9_type;

        /** type for the 10th parameter */
        typedef void param10_type;

        /**
         * Ctor
         */
        delegate(void) : callee(nullptr) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        delegate(const delegate& src) : callee(nullptr) {
            THE_STACK_TRACE;
            (*this) = src;
        }

        /**
         * Move ctor
         *
         * @param src The object to move from
         */
        delegate(delegate&& src) : callee(nullptr) {
            THE_STACK_TRACE;
            this->callee.swap(src.callee);
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5))
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_callee(funcPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        delegate(Rv (*funcPtr)(P1, P2, P3, P4, P5, CT1), CT2 ctxt)
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_context_callee<CT1>(funcPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5))
                : callee(new method_callee<C>(obj, methPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, P5, CT1), CT2 ctxt)
                : callee(new method_context_callee<C, CT1>(obj, methPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~delegate(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool is_target_set(void) const {
            THE_STACK_TRACE;
            return (this->callee != nullptr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param src The source delegate object
         */
        void set(const delegate& src) {
            THE_STACK_TRACE;
            this->callee = src.callee;
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void unset(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        Rv operator()(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
            THE_STACK_TRACE;
            std::shared_ptr<abstract_callee> c = this->callee;
            if (!c) {
                throw the::invalid_operation_exception("Delegate target not set", __FILE__, __LINE__);
            }
            return c->call(p1, p2, p3, p4, p5);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const delegate& rhs) const {
            THE_STACK_TRACE;
            if (!this->callee) {
                return !rhs.callee;
            }
            return this->callee->equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(const delegate& rhs) {
            THE_STACK_TRACE;
            this->callee = rhs.callee;
            return *this;
        }

        /**
         * Move operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(delegate&& rhs) {
            THE_STACK_TRACE;
            this->callee.swap(rhs.callee);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class abstract_callee {
        public:

            /** Ctor */
            abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Dtor */
            virtual ~abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class function_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            function_callee(Rv (*func)(P1, P2, P3, P4, P5)) : abstract_callee(), func(func) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
                THE_STACK_TRACE;
                return this->func(p1, p2, p3, p4, p5);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_callee *r= dynamic_cast<const function_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class function_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            function_context_callee(Rv (*func)(P1, P2, P3, P4, P5, CT1), CT1 ctxt) : abstract_callee(), func(func), ctxt(ctxt) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_context_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
                THE_STACK_TRACE;
                return this->func(p1, p2, p3, p4, p5, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_context_callee *r= dynamic_cast<const function_context_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, P5, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class method_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_callee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5)) : abstract_callee(), obj(obj), meth(meth) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
                THE_STACK_TRACE;
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_callee *r= dynamic_cast<const method_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class method_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_context_callee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, P5, CT1), CT1 ctxt) : abstract_callee(), obj(obj), meth(meth), ctxt(ctxt) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_context_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) {
                THE_STACK_TRACE;
                return (this->obj.*this->meth)(p1, p2, p3, p4, p5, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_context_callee *r= dynamic_cast<const method_context_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, P5, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        std::shared_ptr<abstract_callee> callee;

    };


    /**
     * Template specialication for delegate functions with 4 parameters
     */
    template<class Rv, class P1, class P2, class P3, class P4>
    class delegate<Rv, P1, P2, P3, P4, void, void, void, void, void, void> {
    public:

        /** type for the return value */
        typedef Rv return_value_type;

        /** type for the 1th parameter */
        typedef P1 param1_type;

        /** type for the 2th parameter */
        typedef P2 param2_type;

        /** type for the 3th parameter */
        typedef P3 param3_type;

        /** type for the 4th parameter */
        typedef P4 param4_type;

        /** type for the 5th parameter */
        typedef void param5_type;

        /** type for the 6th parameter */
        typedef void param6_type;

        /** type for the 7th parameter */
        typedef void param7_type;

        /** type for the 8th parameter */
        typedef void param8_type;

        /** type for the 9th parameter */
        typedef void param9_type;

        /** type for the 10th parameter */
        typedef void param10_type;

        /**
         * Ctor
         */
        delegate(void) : callee(nullptr) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        delegate(const delegate& src) : callee(nullptr) {
            THE_STACK_TRACE;
            (*this) = src;
        }

        /**
         * Move ctor
         *
         * @param src The object to move from
         */
        delegate(delegate&& src) : callee(nullptr) {
            THE_STACK_TRACE;
            this->callee.swap(src.callee);
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        delegate(Rv (*funcPtr)(P1, P2, P3, P4))
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_callee(funcPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        delegate(Rv (*funcPtr)(P1, P2, P3, P4, CT1), CT2 ctxt)
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_context_callee<CT1>(funcPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4))
                : callee(new method_callee<C>(obj, methPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, P4, CT1), CT2 ctxt)
                : callee(new method_context_callee<C, CT1>(obj, methPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~delegate(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool is_target_set(void) const {
            THE_STACK_TRACE;
            return (this->callee != nullptr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param src The source delegate object
         */
        void set(const delegate& src) {
            THE_STACK_TRACE;
            this->callee = src.callee;
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void unset(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        Rv operator()(P1 p1, P2 p2, P3 p3, P4 p4) {
            THE_STACK_TRACE;
            std::shared_ptr<abstract_callee> c = this->callee;
            if (!c) {
                throw the::invalid_operation_exception("Delegate target not set", __FILE__, __LINE__);
            }
            return c->call(p1, p2, p3, p4);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const delegate& rhs) const {
            THE_STACK_TRACE;
            if (!this->callee) {
                return !rhs.callee;
            }
            return this->callee->equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(const delegate& rhs) {
            THE_STACK_TRACE;
            this->callee = rhs.callee;
            return *this;
        }

        /**
         * Move operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(delegate&& rhs) {
            THE_STACK_TRACE;
            this->callee.swap(rhs.callee);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class abstract_callee {
        public:

            /** Ctor */
            abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Dtor */
            virtual ~abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class function_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            function_callee(Rv (*func)(P1, P2, P3, P4)) : abstract_callee(), func(func) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4) {
                THE_STACK_TRACE;
                return this->func(p1, p2, p3, p4);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_callee *r= dynamic_cast<const function_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class function_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            function_context_callee(Rv (*func)(P1, P2, P3, P4, CT1), CT1 ctxt) : abstract_callee(), func(func), ctxt(ctxt) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_context_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4) {
                THE_STACK_TRACE;
                return this->func(p1, p2, p3, p4, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_context_callee *r= dynamic_cast<const function_context_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, P4, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class method_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_callee(C& obj, Rv (C::*meth)(P1, P2, P3, P4)) : abstract_callee(), obj(obj), meth(meth) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4) {
                THE_STACK_TRACE;
                return (this->obj.*this->meth)(p1, p2, p3, p4);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_callee *r= dynamic_cast<const method_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class method_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_context_callee(C& obj, Rv (C::*meth)(P1, P2, P3, P4, CT1), CT1 ctxt) : abstract_callee(), obj(obj), meth(meth), ctxt(ctxt) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_context_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3, P4 p4) {
                THE_STACK_TRACE;
                return (this->obj.*this->meth)(p1, p2, p3, p4, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_context_callee *r= dynamic_cast<const method_context_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, P4, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        std::shared_ptr<abstract_callee> callee;

    };


    /**
     * Template specialication for delegate functions with 3 parameters
     */
    template<class Rv, class P1, class P2, class P3>
    class delegate<Rv, P1, P2, P3, void, void, void, void, void, void, void> {
    public:

        /** type for the return value */
        typedef Rv return_value_type;

        /** type for the 1th parameter */
        typedef P1 param1_type;

        /** type for the 2th parameter */
        typedef P2 param2_type;

        /** type for the 3th parameter */
        typedef P3 param3_type;

        /** type for the 4th parameter */
        typedef void param4_type;

        /** type for the 5th parameter */
        typedef void param5_type;

        /** type for the 6th parameter */
        typedef void param6_type;

        /** type for the 7th parameter */
        typedef void param7_type;

        /** type for the 8th parameter */
        typedef void param8_type;

        /** type for the 9th parameter */
        typedef void param9_type;

        /** type for the 10th parameter */
        typedef void param10_type;

        /**
         * Ctor
         */
        delegate(void) : callee(nullptr) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        delegate(const delegate& src) : callee(nullptr) {
            THE_STACK_TRACE;
            (*this) = src;
        }

        /**
         * Move ctor
         *
         * @param src The object to move from
         */
        delegate(delegate&& src) : callee(nullptr) {
            THE_STACK_TRACE;
            this->callee.swap(src.callee);
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        delegate(Rv (*funcPtr)(P1, P2, P3))
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_callee(funcPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        delegate(Rv (*funcPtr)(P1, P2, P3, CT1), CT2 ctxt)
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_context_callee<CT1>(funcPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3))
                : callee(new method_callee<C>(obj, methPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        delegate(C& obj, Rv (C::*methPtr)(P1, P2, P3, CT1), CT2 ctxt)
                : callee(new method_context_callee<C, CT1>(obj, methPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~delegate(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool is_target_set(void) const {
            THE_STACK_TRACE;
            return (this->callee != nullptr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param src The source delegate object
         */
        void set(const delegate& src) {
            THE_STACK_TRACE;
            this->callee = src.callee;
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void unset(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        Rv operator()(P1 p1, P2 p2, P3 p3) {
            THE_STACK_TRACE;
            std::shared_ptr<abstract_callee> c = this->callee;
            if (!c) {
                throw the::invalid_operation_exception("Delegate target not set", __FILE__, __LINE__);
            }
            return c->call(p1, p2, p3);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const delegate& rhs) const {
            THE_STACK_TRACE;
            if (!this->callee) {
                return !rhs.callee;
            }
            return this->callee->equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(const delegate& rhs) {
            THE_STACK_TRACE;
            this->callee = rhs.callee;
            return *this;
        }

        /**
         * Move operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(delegate&& rhs) {
            THE_STACK_TRACE;
            this->callee.swap(rhs.callee);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class abstract_callee {
        public:

            /** Ctor */
            abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Dtor */
            virtual ~abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class function_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            function_callee(Rv (*func)(P1, P2, P3)) : abstract_callee(), func(func) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3) {
                THE_STACK_TRACE;
                return this->func(p1, p2, p3);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_callee *r= dynamic_cast<const function_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class function_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            function_context_callee(Rv (*func)(P1, P2, P3, CT1), CT1 ctxt) : abstract_callee(), func(func), ctxt(ctxt) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_context_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3) {
                THE_STACK_TRACE;
                return this->func(p1, p2, p3, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_context_callee *r= dynamic_cast<const function_context_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, P3, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class method_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_callee(C& obj, Rv (C::*meth)(P1, P2, P3)) : abstract_callee(), obj(obj), meth(meth) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3) {
                THE_STACK_TRACE;
                return (this->obj.*this->meth)(p1, p2, p3);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_callee *r= dynamic_cast<const method_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class method_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_context_callee(C& obj, Rv (C::*meth)(P1, P2, P3, CT1), CT1 ctxt) : abstract_callee(), obj(obj), meth(meth), ctxt(ctxt) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_context_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2, P3 p3) {
                THE_STACK_TRACE;
                return (this->obj.*this->meth)(p1, p2, p3, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_context_callee *r= dynamic_cast<const method_context_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, P3, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        std::shared_ptr<abstract_callee> callee;

    };


    /**
     * Template specialication for delegate functions with 2 parameters
     */
    template<class Rv, class P1, class P2>
    class delegate<Rv, P1, P2, void, void, void, void, void, void, void, void> {
    public:

        /** type for the return value */
        typedef Rv return_value_type;

        /** type for the 1th parameter */
        typedef P1 param1_type;

        /** type for the 2th parameter */
        typedef P2 param2_type;

        /** type for the 3th parameter */
        typedef void param3_type;

        /** type for the 4th parameter */
        typedef void param4_type;

        /** type for the 5th parameter */
        typedef void param5_type;

        /** type for the 6th parameter */
        typedef void param6_type;

        /** type for the 7th parameter */
        typedef void param7_type;

        /** type for the 8th parameter */
        typedef void param8_type;

        /** type for the 9th parameter */
        typedef void param9_type;

        /** type for the 10th parameter */
        typedef void param10_type;

        /**
         * Ctor
         */
        delegate(void) : callee(nullptr) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        delegate(const delegate& src) : callee(nullptr) {
            THE_STACK_TRACE;
            (*this) = src;
        }

        /**
         * Move ctor
         *
         * @param src The object to move from
         */
        delegate(delegate&& src) : callee(nullptr) {
            THE_STACK_TRACE;
            this->callee.swap(src.callee);
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        delegate(Rv (*funcPtr)(P1, P2))
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_callee(funcPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        delegate(Rv (*funcPtr)(P1, P2, CT1), CT2 ctxt)
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_context_callee<CT1>(funcPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        delegate(C& obj, Rv (C::*methPtr)(P1, P2))
                : callee(new method_callee<C>(obj, methPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        delegate(C& obj, Rv (C::*methPtr)(P1, P2, CT1), CT2 ctxt)
                : callee(new method_context_callee<C, CT1>(obj, methPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~delegate(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool is_target_set(void) const {
            THE_STACK_TRACE;
            return (this->callee != nullptr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param src The source delegate object
         */
        void set(const delegate& src) {
            THE_STACK_TRACE;
            this->callee = src.callee;
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void unset(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        Rv operator()(P1 p1, P2 p2) {
            THE_STACK_TRACE;
            std::shared_ptr<abstract_callee> c = this->callee;
            if (!c) {
                throw the::invalid_operation_exception("Delegate target not set", __FILE__, __LINE__);
            }
            return c->call(p1, p2);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const delegate& rhs) const {
            THE_STACK_TRACE;
            if (!this->callee) {
                return !rhs.callee;
            }
            return this->callee->equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(const delegate& rhs) {
            THE_STACK_TRACE;
            this->callee = rhs.callee;
            return *this;
        }

        /**
         * Move operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(delegate&& rhs) {
            THE_STACK_TRACE;
            this->callee.swap(rhs.callee);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class abstract_callee {
        public:

            /** Ctor */
            abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Dtor */
            virtual ~abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class function_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            function_callee(Rv (*func)(P1, P2)) : abstract_callee(), func(func) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2) {
                THE_STACK_TRACE;
                return this->func(p1, p2);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_callee *r= dynamic_cast<const function_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class function_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            function_context_callee(Rv (*func)(P1, P2, CT1), CT1 ctxt) : abstract_callee(), func(func), ctxt(ctxt) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_context_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2) {
                THE_STACK_TRACE;
                return this->func(p1, p2, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_context_callee *r= dynamic_cast<const function_context_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, P2, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class method_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_callee(C& obj, Rv (C::*meth)(P1, P2)) : abstract_callee(), obj(obj), meth(meth) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2) {
                THE_STACK_TRACE;
                return (this->obj.*this->meth)(p1, p2);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_callee *r= dynamic_cast<const method_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class method_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_context_callee(C& obj, Rv (C::*meth)(P1, P2, CT1), CT1 ctxt) : abstract_callee(), obj(obj), meth(meth), ctxt(ctxt) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_context_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1, P2 p2) {
                THE_STACK_TRACE;
                return (this->obj.*this->meth)(p1, p2, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_context_callee *r= dynamic_cast<const method_context_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, P2, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        std::shared_ptr<abstract_callee> callee;

    };


    /**
     * Template specialication for delegate functions with 1 parameters
     */
    template<class Rv, class P1>
    class delegate<Rv, P1, void, void, void, void, void, void, void, void, void> {
    public:

        /** type for the return value */
        typedef Rv return_value_type;

        /** type for the 1th parameter */
        typedef P1 param1_type;

        /** type for the 2th parameter */
        typedef void param2_type;

        /** type for the 3th parameter */
        typedef void param3_type;

        /** type for the 4th parameter */
        typedef void param4_type;

        /** type for the 5th parameter */
        typedef void param5_type;

        /** type for the 6th parameter */
        typedef void param6_type;

        /** type for the 7th parameter */
        typedef void param7_type;

        /** type for the 8th parameter */
        typedef void param8_type;

        /** type for the 9th parameter */
        typedef void param9_type;

        /** type for the 10th parameter */
        typedef void param10_type;

        /**
         * Ctor
         */
        delegate(void) : callee(nullptr) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        delegate(const delegate& src) : callee(nullptr) {
            THE_STACK_TRACE;
            (*this) = src;
        }

        /**
         * Move ctor
         *
         * @param src The object to move from
         */
        delegate(delegate&& src) : callee(nullptr) {
            THE_STACK_TRACE;
            this->callee.swap(src.callee);
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        delegate(Rv (*funcPtr)(P1))
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_callee(funcPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        delegate(Rv (*funcPtr)(P1, CT1), CT2 ctxt)
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_context_callee<CT1>(funcPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        delegate(C& obj, Rv (C::*methPtr)(P1))
                : callee(new method_callee<C>(obj, methPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        delegate(C& obj, Rv (C::*methPtr)(P1, CT1), CT2 ctxt)
                : callee(new method_context_callee<C, CT1>(obj, methPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~delegate(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool is_target_set(void) const {
            THE_STACK_TRACE;
            return (this->callee != nullptr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param src The source delegate object
         */
        void set(const delegate& src) {
            THE_STACK_TRACE;
            this->callee = src.callee;
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void unset(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        Rv operator()(P1 p1) {
            THE_STACK_TRACE;
            std::shared_ptr<abstract_callee> c = this->callee;
            if (!c) {
                throw the::invalid_operation_exception("Delegate target not set", __FILE__, __LINE__);
            }
            return c->call(p1);
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const delegate& rhs) const {
            THE_STACK_TRACE;
            if (!this->callee) {
                return !rhs.callee;
            }
            return this->callee->equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(const delegate& rhs) {
            THE_STACK_TRACE;
            this->callee = rhs.callee;
            return *this;
        }

        /**
         * Move operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(delegate&& rhs) {
            THE_STACK_TRACE;
            this->callee.swap(rhs.callee);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class abstract_callee {
        public:

            /** Ctor */
            abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Dtor */
            virtual ~abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Call */
            virtual Rv call(P1 p1) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class function_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            function_callee(Rv (*func)(P1)) : abstract_callee(), func(func) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1) {
                THE_STACK_TRACE;
                return this->func(p1);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_callee *r= dynamic_cast<const function_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class function_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            function_context_callee(Rv (*func)(P1, CT1), CT1 ctxt) : abstract_callee(), func(func), ctxt(ctxt) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_context_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1) {
                THE_STACK_TRACE;
                return this->func(p1, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_context_callee *r= dynamic_cast<const function_context_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            Rv (*func)(P1, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class method_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_callee(C& obj, Rv (C::*meth)(P1)) : abstract_callee(), obj(obj), meth(meth) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1) {
                THE_STACK_TRACE;
                return (this->obj.*this->meth)(p1);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_callee *r= dynamic_cast<const method_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class method_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_context_callee(C& obj, Rv (C::*meth)(P1, CT1), CT1 ctxt) : abstract_callee(), obj(obj), meth(meth), ctxt(ctxt) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_context_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(P1 p1) {
                THE_STACK_TRACE;
                return (this->obj.*this->meth)(p1, this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_context_callee *r= dynamic_cast<const method_context_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(P1, CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        std::shared_ptr<abstract_callee> callee;

    };


    /**
     * Template specialication for delegate functions with 0 parameters
     */
    template<class Rv>
    class delegate<Rv, void, void, void, void, void, void, void, void, void, void> {
    public:

        /** type for the return value */
        typedef Rv return_value_type;

        /** type for the 1th parameter */
        typedef void param1_type;

        /** type for the 2th parameter */
        typedef void param2_type;

        /** type for the 3th parameter */
        typedef void param3_type;

        /** type for the 4th parameter */
        typedef void param4_type;

        /** type for the 5th parameter */
        typedef void param5_type;

        /** type for the 6th parameter */
        typedef void param6_type;

        /** type for the 7th parameter */
        typedef void param7_type;

        /** type for the 8th parameter */
        typedef void param8_type;

        /** type for the 9th parameter */
        typedef void param9_type;

        /** type for the 10th parameter */
        typedef void param10_type;

        /**
         * Ctor
         */
        delegate(void) : callee(nullptr) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        delegate(const delegate& src) : callee(nullptr) {
            THE_STACK_TRACE;
            (*this) = src;
        }

        /**
         * Move ctor
         *
         * @param src The object to move from
         */
        delegate(delegate&& src) : callee(nullptr) {
            THE_STACK_TRACE;
            this->callee.swap(src.callee);
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        delegate(Rv (*funcPtr)(void))
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_callee(funcPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        delegate(Rv (*funcPtr)(CT1), CT2 ctxt)
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_context_callee<CT1>(funcPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        delegate(C& obj, Rv (C::*methPtr)(void))
                : callee(new method_callee<C>(obj, methPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        delegate(C& obj, Rv (C::*methPtr)(CT1), CT2 ctxt)
                : callee(new method_context_callee<C, CT1>(obj, methPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~delegate(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool is_target_set(void) const {
            THE_STACK_TRACE;
            return (this->callee != nullptr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param src The source delegate object
         */
        void set(const delegate& src) {
            THE_STACK_TRACE;
            this->callee = src.callee;
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void unset(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        Rv operator()(void) {
            THE_STACK_TRACE;
            std::shared_ptr<abstract_callee> c = this->callee;
            if (!c) {
                throw the::invalid_operation_exception("Delegate target not set", __FILE__, __LINE__);
            }
            return c->call();
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const delegate& rhs) const {
            THE_STACK_TRACE;
            if (!this->callee) {
                return !rhs.callee;
            }
            return this->callee->equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(const delegate& rhs) {
            THE_STACK_TRACE;
            this->callee = rhs.callee;
            return *this;
        }

        /**
         * Move operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(delegate&& rhs) {
            THE_STACK_TRACE;
            this->callee.swap(rhs.callee);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class abstract_callee {
        public:

            /** Ctor */
            abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Dtor */
            virtual ~abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Call */
            virtual Rv call(void) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class function_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            function_callee(Rv (*func)(void)) : abstract_callee(), func(func) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(void) {
                THE_STACK_TRACE;
                return this->func();
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_callee *r= dynamic_cast<const function_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            Rv (*func)(void);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class function_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            function_context_callee(Rv (*func)(CT1), CT1 ctxt) : abstract_callee(), func(func), ctxt(ctxt) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_context_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(void) {
                THE_STACK_TRACE;
                return this->func(this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_context_callee *r= dynamic_cast<const function_context_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            Rv (*func)(CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class method_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_callee(C& obj, Rv (C::*meth)(void)) : abstract_callee(), obj(obj), meth(meth) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(void) {
                THE_STACK_TRACE;
                return (this->obj.*this->meth)();
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_callee *r= dynamic_cast<const method_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(void);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class method_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_context_callee(C& obj, Rv (C::*meth)(CT1), CT1 ctxt) : abstract_callee(), obj(obj), meth(meth), ctxt(ctxt) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_context_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual Rv call(void) {
                THE_STACK_TRACE;
                return (this->obj.*this->meth)(this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_context_callee *r= dynamic_cast<const method_context_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            Rv (C::*meth)(CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        std::shared_ptr<abstract_callee> callee;

    };


    /**
     * Template specialication for delegate functions without parameters and
     * without return value.
     */
    template<>
    class delegate<void, void, void, void, void, void, void, void, void, void, void> {
    public:

        /** type for the return value */
        typedef void return_value_type;

        /** type for the 1th parameter */
        typedef void param1_type;

        /** type for the 2th parameter */
        typedef void param2_type;

        /** type for the 3th parameter */
        typedef void param3_type;

        /** type for the 4th parameter */
        typedef void param4_type;

        /** type for the 5th parameter */
        typedef void param5_type;

        /** type for the 6th parameter */
        typedef void param6_type;

        /** type for the 7th parameter */
        typedef void param7_type;

        /** type for the 8th parameter */
        typedef void param8_type;

        /** type for the 9th parameter */
        typedef void param9_type;

        /** type for the 10th parameter */
        typedef void param10_type;

        /**
         * Ctor
         */
        delegate(void) : callee(nullptr) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Copy ctor
         *
         * @param src The object to clone from
         */
        delegate(const delegate& src) : callee(nullptr) {
            THE_STACK_TRACE;
            (*this) = src;
        }

        /**
         * Move ctor
         *
         * @param src The object to move from
         */
        delegate(delegate&& src) : callee(nullptr) {
            THE_STACK_TRACE;
            this->callee.swap(src.callee);
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         */
        delegate(void (*funcPtr)(void))
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_callee(funcPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param funcPtr Function pointer to be set
         * @param ctxt The user data context used when calling the function
         */
        template<class CT1, class CT2>
        delegate(void (*funcPtr)(CT1), CT2 ctxt)
                : callee((funcPtr == nullptr)
                    ? nullptr
                    : new function_context_callee<CT1>(funcPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         */
        template<class C>
        delegate(C& obj, void (C::*methPtr)(void))
                : callee(new method_callee<C>(obj, methPtr)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Ctor
         *
         * @param obj The object to call the member of
         * @param methPtr The method class pointer to be set (must not be NULL)
         * @param ctxt The user data context used when calling the method
         */
        template<class C, class CT1, class CT2>
        delegate(C& obj, void (C::*methPtr)(CT1), CT2 ctxt)
                : callee(new method_context_callee<C, CT1>(obj, methPtr, ctxt)) {
            THE_STACK_TRACE;
            // intentionally empty
        }

        /**
         * Dtor
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        ~delegate(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Answer whether the target for this delegate is set
         *
         * @return True if the target for this delegate is set
         */
        inline bool is_target_set(void) const {
            THE_STACK_TRACE;
            return (this->callee != nullptr);
        }

        /**
         * Sets the target for this delegate
         *
         * @param src The source delegate object
         */
        void set(const delegate& src) {
            THE_STACK_TRACE;
            this->callee = src.callee;
        }

        /**
         * Unsets the target for this delegate
         *
         * Note that no memory will be freed (user data context, etc.)
         */
        void unset(void) {
            THE_STACK_TRACE;
            this->callee.reset();
        }

        /**
         * Calls the delegate's target
         *
         * Parameter and return value depend on the template arguments of the delegate
         */
        void operator()(void) {
            THE_STACK_TRACE;
            std::shared_ptr<abstract_callee> c = this->callee;
            if (!c) {
                throw the::invalid_operation_exception("Delegate target not set", __FILE__, __LINE__);
            }
            c->call();
        }

        /**
         * Test for equality
         *
         * @param rhs The right hand side operand
         *
         * @return True if this and rhs are equal
         */
        bool operator==(const delegate& rhs) const {
            THE_STACK_TRACE;
            if (!this->callee) {
                return !rhs.callee;
            }
            return this->callee->equals(*rhs.callee);
        }

        /**
         * Assignment operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(const delegate& rhs) {
            THE_STACK_TRACE;
            this->callee = rhs.callee;
            return *this;
        }

        /**
         * Move operator
         *
         * @param rhs The right hand side operand
         *
         * @return A reference to this object
         */
        delegate& operator=(delegate&& rhs) {
            THE_STACK_TRACE;
            this->callee.swap(rhs.callee);
            return *this;
        }

    private:

        /**
         * abstract base class for callee implementations
         */
        class abstract_callee {
        public:

            /** Ctor */
            abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Dtor */
            virtual ~abstract_callee(void) {
                THE_STACK_TRACE;
                // intentionally empty
            }

            /** Call */
            virtual void call(void) = 0;

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) = 0;

        };

        /**
         * Callee implementation for functions
         */
        class function_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             */
            function_callee(void (*func)(void)) : abstract_callee(), func(func) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual void call(void) {
                THE_STACK_TRACE;
                this->func();
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_callee *r= dynamic_cast<const function_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func);
            }

        private:

            /** The function pointer */
            void (*func)(void);

        };

        /**
         * Callee implementation for functions with user data context
         */
        template<class CT1>
        class function_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The function pointer (must not be NULL)
             * @param ctxt The user data context
             */
            function_context_callee(void (*func)(CT1), CT1 ctxt) : abstract_callee(), func(func), ctxt(ctxt) {
                THE_ASSERT(this->func != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~function_context_callee(void) {
                THE_STACK_TRACE;
                this->func = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual void call(void) {
                THE_STACK_TRACE;
                this->func(this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const function_context_callee *r= dynamic_cast<const function_context_callee*>(&rhs);
                return (r != nullptr)
                    && (r->func == this->func)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The function pointer */
            void (*func)(CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /**
         * Callee implementation for methods
         */
        template<class C>
        class method_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_callee(C& obj, void (C::*meth)(void)) : abstract_callee(), obj(obj), meth(meth) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual void call(void) {
                THE_STACK_TRACE;
                (this->obj.*this->meth)();
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_callee *r= dynamic_cast<const method_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            void (C::*meth)(void);

        };

        /**
         * Callee implementation for methods with user data context
         */
        template<class C, class CT1>
        class method_context_callee : public abstract_callee {
        public:

            /**
             * Ctor
             *
             * @param obj The object
             * @param func The method pointer (must not be NULL)
             * @param ctxt The user data context
             */
            method_context_callee(C& obj, void (C::*meth)(CT1), CT1 ctxt) : abstract_callee(), obj(obj), meth(meth), ctxt(ctxt) {
                THE_ASSERT(this->meth != nullptr);
                THE_STACK_TRACE;
            }

            /** Dtor */
            virtual ~method_context_callee(void) {
                THE_STACK_TRACE;
                this->meth = nullptr; // DO NOT DELETE
            }

            /** Call */
            virtual void call(void) {
                THE_STACK_TRACE;
                (this->obj.*this->meth)(this->ctxt);
            }

            /**
             * Test for equality
             *
             * @param rhs The right hand side operand
             *
             * @return True if this and rhs are equal
             */
            virtual bool equals(const abstract_callee& rhs) {
                THE_STACK_TRACE;
                const method_context_callee *r= dynamic_cast<const method_context_callee*>(&rhs);
                return (r != nullptr)
                    && (&r->obj == &this->obj)
                    && (r->meth == this->meth)
                    && (r->ctxt == this->ctxt);
            }

        private:

            /** The object */
            C& obj;

            /** The method pointer */
            void (C::*meth)(CT1);

            /** The user data context */
            CT1 ctxt;

        };

        /** The callee target */
        std::shared_ptr<abstract_callee> callee;

    };

} /* end namespace the */

#if defined(_WIN32) && defined(_MANAGED)
#pragma managed(pop)
#endif /* defined(_WIN32) && defined(_MANAGED) */
#endif /* THE_DELEGATE_H_INCLUDED */
